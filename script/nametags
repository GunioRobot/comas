#!/usr/bin/ruby 
require File.dirname(__FILE__) + '/../config/boot'
require 'environment'

require 'gettext'
require 'libglade2'
require 'singleton'

class NametagApp
  def initialize
    app = NametagsGlade.new('lib/nametags/nametags.glade')
    app.show

    Gtk.main
  end
end

class NametagsGlade
  include GetText
  bindtextdomain("comas", 'locale')
  attr :glade

  def initialize(path_or_data, root = nil, domain = 'comas', 
                 localedir = 'locale', flag = GladeXML::FILE)
    bindtextdomain(domain, localedir, nil, "UTF-8")

    @glade = GladeXML.new(path_or_data, root, domain, 
                          localedir, flag) {|handler| method(handler)}

    setup_conferences_list(@glade["conference_combobox"])
    setup_people_list(@glade["peoplelist_treeview"])
  end

  def show
    @window = @glade['window1']
    @window.show_all
    @window.signal_connect("destroy") { Gtk.main_quit }
  end

  ############################################################
  # Callbacks

  def on_conference_combobox_changed(combo)
    # Text: combo.active_iter[0]
    # ID: combo.active_iter[1]
    populate_people(@glade['peoplelist_treeview'].model, combo.active_iter[1])    
  end

  def on_quit_button_clicked(button)
    Gtk.main_quit
  end

  def on_peoplelist_treeview_row_activated(view, path, column)
    return unless iter = view.model.get_iter(path)
    print_label_for(@people[iter[0]])
  end

  def on_print_button_clicked(button)
    return unless iter = @glade["peoplelist_treeview"].selection.selected
    print_label_for(@people[iter[0]])
  end

  def on_refresh_button_clicked(button)
    populate_people(@glade["peoplelist_treeview"].model,
                    @glade["conference_combobox"].active_iter[1])
  end

  private
  def setup_people_list(treeview)
    model = Gtk::ListStore.new(Integer, String, String, String, Person)
    treeview.model = model

    colnum = 0
    [_('ID'), _('First name'), _('Family name'), _('Login')].each do |title|
      col = Gtk::TreeViewColumn.new(title, 
                                    Gtk::CellRendererText.new,
                                    'text' => colnum)
      col.clickable = true
      col.resizable = true
      col.sort_column_id = colnum
      treeview.append_column(col)
      colnum += 1
    end

    populate_people(model)
  end

  def populate_people(model, conf_id = 0)
    model.clear
    status = @glade['statusbar']
    if conf_id > 0
      begin
        conf = Conference.find(conf_id, :include => 'people')
        people_list_from conf.people
      rescue
        # Any problems? Update the conferences (maybe a conference was
        # deleted since we were invoked?) listing and return the full people
        # list.
        populate_conferences_list(@glade["conference_combobox"].model)
        populate_people(model)
        return true
      end
    else
      people_list_from Person.find(:all)
    end

    @people.values.each do |pers|
      iter = model.append
      iter[0] = pers.id
      iter[1] = pers.firstname
      iter[2] = pers.famname
      iter[3] = pers.login
    end
    status.push(status.get_context_id('populate_people'),
                _("Displaying %d people") % @people.size)
  end

  def people_list_from(collection)
    @people = {}
    collection.each {|pers| @people[pers.id] = pers}
  end

  def setup_conferences_list(combo)
    model = Gtk::ListStore.new(String, Integer)
    cell = Gtk::CellRendererText.new()
    combo.pack_start(cell, true)
    combo.add_attribute(cell, 'text', 0)
    combo.set_model(model)
    populate_conferences_list(model)
  end

  def populate_conferences_list(model)
    model.clear # Just in case we are being refreshed
    model.append # Add and activate an empty line to begin with
    Conference.find(:all, :order => :name).each do |conf|
      iter = model.append
      iter[0] = conf.name
      iter[1] = conf.id
    end
  end

  def print_label_for(person)
    ZebraLabel.new(person).print
  end
end

class ZebraLabel
  LabelDimensions = {:width => 528, :gap => 5, :height => 263,
    :cutoff_chars => 12}

  def initialize(person)
    @label = {:id => '%05d' % person.id,
      :firstname => person.firstname,
      :famname => person.famname,
      :email => person.email
    }
    @label[:first_width] = font_width_for @label[:firstname]
    @label[:fam_width] = font_width_for @label[:famname]
    # PENDING: Adding extra fields to nametag
  end

  def print
    ZebraPrinter.instance.print(build_label)
  end

  private
  def build_label
    l = @label
    [ 'Q%d,%d' % [ LabelDimensions[:height], 
                   LabelDimensions[:gap] ],
      'q%d' % LabelDimensions[:width],
      'N',
      'A30,5,0,4,%d,2,N,"%s"' % [ l[:first_width], l[:firstname] ],
      'A30,55,0,4,%d,2,N,"%s"' % [ l[:fam_width], l[:famname] ],
      'A30,120,0,3,1,1,N,"%s"' % l[:email],
      # 'A30,145,0,3,1,1,N,"$person->{org}"',
      'B480,5,1,1,3,5,70,B,$id',
      # 'A30,170,0,5,1,1,R,"$person->{pers_type}"',
      'P',
      '' # To force a final newline
    ].join("\n")
  end

  def font_width_for(label)
    label.size > LabelDimensions[:cutoff_chars] ? 1 : 2
  end
end

class ZebraPrinter
  include Singleton
  PrinterPort = '/dev/lp0' # Should be customizable...

  def print(data)
    File.open(PrinterPort, 'w') { |out| out.print(data) }
  end
end

ENV['GETTEXT_PATH'] ||= File.join(File.dirname(__FILE__), 'locale')
Locale.set(ENV['LANG']) if ENV['LANG']
NametagApp.new
